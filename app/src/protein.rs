use std::fs;
use std::io::Write;
use std::path::Path;

use folding_molecule::{PeptideChain, Residue};

/// Representation of an input protein sequence along with optional metadata.
#[derive(Debug, Clone)]
pub struct ProteinSequence {
    pub identifier: Option<String>,
    pub sequence: String,
}

impl ProteinSequence {
    pub fn len(&self) -> usize {
        self.sequence.len()
    }

    pub fn to_chain(&self) -> PeptideChain {
        PeptideChain::from_sequence(&self.sequence)
    }
}

/// Loads a sequence either from FASTA or a minimal JSON file.
pub fn load_sequence(path: &Path) -> Result<ProteinSequence, String> {
    let contents = fs::read_to_string(path)
        .map_err(|err| format!("failed to read sequence {}: {err}", path.display()))?;
    if looks_like_json(&contents) {
        parse_json_sequence(&contents)
    } else {
        parse_fasta_sequence(&contents)
    }
}

fn looks_like_json(contents: &str) -> bool {
    let trimmed = contents.trim_start();
    trimmed.starts_with('{') || trimmed.starts_with('[')
}

fn parse_fasta_sequence(contents: &str) -> Result<ProteinSequence, String> {
    let mut identifier: Option<String> = None;
    let mut sequence = String::new();
    for line in contents.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() {
            continue;
        }
        if let Some(rest) = trimmed.strip_prefix('>') {
            if identifier.is_none() {
                identifier = Some(rest.trim().to_string());
            }
            continue;
        }
        sequence.extend(trimmed.chars().filter(|ch| !ch.is_whitespace()));
    }
    if sequence.is_empty() {
        return Err("FASTA sequence contained no residues".into());
    }
    Ok(ProteinSequence {
        identifier,
        sequence,
    })
}

fn parse_json_sequence(contents: &str) -> Result<ProteinSequence, String> {
    let sequence = extract_json_value(contents, "sequence")
        .ok_or_else(|| "JSON input missing 'sequence' field".to_string())?;
    if sequence.trim().is_empty() {
        return Err("JSON sequence field was empty".into());
    }
    let identifier = extract_json_value(contents, "id");
    Ok(ProteinSequence {
        identifier,
        sequence,
    })
}

fn extract_json_value(contents: &str, key: &str) -> Option<String> {
    let needle = format!("\"{key}\"");
    let start = contents.find(&needle)?;
    let remainder = &contents[start + needle.len()..];
    let colon_index = remainder.find(':')?;
    let remainder = &remainder[colon_index + 1..];
    let mut in_string = false;
    let mut escape = false;
    let mut value = String::new();
    for ch in remainder.chars() {
        if !in_string {
            if ch == '"' {
                in_string = true;
            } else if !ch.is_whitespace() {
                // The value is not a string literal; unsupported.
                return None;
            }
            continue;
        }
        if escape {
            value.push(ch);
            escape = false;
            continue;
        }
        match ch {
            '\\' => {
                escape = true;
            }
            '"' => {
                return Some(value);
            }
            _ => value.push(ch),
        }
    }
    None
}

/// Writes a simple C-alpha-only PDB file.
pub fn write_pdb(
    chain: &PeptideChain,
    path: &Path,
    sequence: &ProteinSequence,
) -> Result<(), String> {
    let mut file = fs::File::create(path)
        .map_err(|err| format!("failed to create PDB {}: {err}", path.display()))?;

    if let Some(id) = &sequence.identifier {
        writeln!(file, "HEADER    LOGLINE FOLD | {}", id)
            .map_err(|err| format!("failed to write header: {err}"))?;
    } else {
        writeln!(file, "HEADER    LOGLINE FOLD")
            .map_err(|err| format!("failed to write header: {err}"))?;
    }
    writeln!(file, "TITLE     Mock folding trace generated by LogLine")
        .map_err(|err| format!("failed to write title: {err}"))?;

    for (index, residue) in chain.residues().iter().enumerate() {
        write_atom_line(&mut file, index + 1, residue)
            .map_err(|err| format!("failed to write atom line: {err}"))?;
    }

    writeln!(file, "TER").map_err(|err| format!("failed to write terminator: {err}"))?;
    writeln!(file, "END").map_err(|err| format!("failed to write footer: {err}"))?;
    Ok(())
}

fn write_atom_line(
    mut writer: impl Write,
    serial: usize,
    residue: &Residue,
) -> std::io::Result<()> {
    let position = residue.position();
    // PDB ATOM format with only C-alpha atoms.
    writeln!(
        writer,
        "ATOM  {:>5}  CA  {:>3} A{:>4}    {:>8.3}{:>8.3}{:>8.3}  1.00  0.00           C",
        serial,
        residue.name,
        residue.id.0 + 1,
        position[0],
        position[1],
        position[2],
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_simple_fasta() {
        let contents = ">seq\nACDE";
        let seq = parse_fasta_sequence(contents).unwrap();
        assert_eq!(seq.sequence, "ACDE");
        assert_eq!(seq.identifier.as_deref(), Some("seq"));
    }

    #[test]
    fn parse_json_payload() {
        let contents = "{\"id\":\"demo\",\"sequence\":\"ACD\"}";
        let seq = parse_json_sequence(contents).unwrap();
        assert_eq!(seq.sequence, "ACD");
        assert_eq!(seq.identifier.as_deref(), Some("demo"));
    }

    #[test]
    fn write_pdb_generates_atom_lines() {
        let seq = ProteinSequence {
            identifier: Some("demo".into()),
            sequence: "ACD".into(),
        };
        let chain = seq.to_chain();
        let mut path = std::env::temp_dir();
        path.push("test_write.pdb");
        write_pdb(&chain, &path, &seq).unwrap();
        let contents = fs::read_to_string(&path).unwrap();
        assert!(contents.contains("ATOM"));
        assert!(contents.contains("END"));
        let _ = fs::remove_file(path);
    }
}
